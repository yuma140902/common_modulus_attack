use ibig::{modular::ModuloRing, ops::Abs as _, IBig, UBig};

fn main() {
    let e1: UBig = "11".parse().unwrap();
    let c1: UBig = "80265690974140286785447882525076768851800986505783169077080797677035805215248640465159446426193422263912423067392651719120282968933314718780685629466284745121303594495759721471318134122366715904".parse().unwrap();
    let e2: UBig = "13".parse().unwrap();
    let c2: UBig = "14451037575679461333658489727928902053807202350950440400755535465672646289383249206721118279217195146247129636809289035793102103248547070620691905918862697416910065303500798664102685376006097589955370023822867897020714767877873664".parse().unwrap();
    let n: UBig = "236934049743116267137999082243372631809789567482083918717832642810097363305512293474568071369055296264199854438630820352634325357252399203160052660683745421710174826323192475870497319105418435646820494864987787286941817224659073497212768480618387152477878449603008187097148599534206055318807657902493850180695091646575878916531742076951110529004783428260456713315007812112632429296257313525506207087475539303737022587194108436132757979273391594299137176227924904126161234005321583720836733205639052615538054399452669637400105028428545751844036229657412844469034970807562336527158965779903175305550570647732255961850364080642984562893392375273054434538280546913977098212083374336482279710348958536764229803743404325258229707314844255917497531735251105389366176228741806064378293682890877558325834873371615135474627913981994123692172918524625407966731238257519603614744577".parse().unwrap();
    let result = common_modulus_attack(e1, e2, c1, c2, n);
    println!("{}", result);
}

fn common_modulus_attack(e1: UBig, e2: UBig, mut c1: UBig, mut c2: UBig, n: UBig) -> IBig {
    let (_gcd, s1signed, s2signed) = e1.extended_gcd(&e2);
    let n_ring = ModuloRing::new(&n);

    let s1: UBig = s1signed.clone().abs().try_into().unwrap();
    let s2: UBig = s2signed.clone().abs().try_into().unwrap();
    if s1signed < 0.into() {
        c1 = n_ring.from(c1).inverse().unwrap().residue();
    }
    if s2signed < 0.into() {
        c2 = n_ring.from(c2).inverse().unwrap().residue();
    }

    let m1: IBig = n_ring.from(c1).pow(&s1).residue().into();
    let m2: IBig = n_ring.from(c2).pow(&s2).residue().into();
    let n: IBig = n.into();
    m1 * m2 % n
}
